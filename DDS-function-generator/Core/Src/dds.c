/*
 * dds.c
 *
 *  Created on: Jan 29, 2022
 *      Author: bojan
 */

#include "dds.h"

/**************************************
 * Interface functions
 **************************************/

/**************************************
 * Initialize the DDS waveform generator
 **************************************/
void DDS_Init(	DDS *dds, const uint8_t *wavetable, uint16_t wavetableSize, WaveformType waveType, uint32_t freq, uint32_t amp,
				GPIO_TypeDef *gpio, TIM_HandleTypeDef *htim, TIM_HandleTypeDef *htimOffset) {

	dds->gpio = gpio;	// NOTE: the lower 8 pins of the port must be previously
						// configured as outputs and with max output speed
	dds->htim = htim;
	dds->htimOffset = htimOffset;

	DDS_ChangeWaveform(dds, wavetable, wavetableSize, waveType);	// set the requested waveform
	DDS_ChangeFrequency(dds, freq);									// set the requested frequency
	DDS_ChangeAmplitude(dds, amp);									// set the requested amplitude

	// enable timer DMA request when timer overflows
	__HAL_TIM_ENABLE_DMA(dds->htim, TIM_DMA_UPDATE);

	dds->running = 0;	// by default, waveform generator is not running

	DDS_Update(dds);	// update the changes

}

/**************************************
 * Start DDS waveform generation
 **************************************/
void DDS_Start(DDS *dds) {
	// reset the timer to 0
	__HAL_TIM_SET_COUNTER(dds->htim, 0);
	// start the timer
	HAL_TIM_Base_Start(dds->htim);
	// start the dma transfer
	HAL_DMA_Start(dds->htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&dds->wavetable, (uint32_t)&dds->gpio->ODR, dds->wavetableSize);
	// start the timer for PWM generation
	HAL_TIM_PWM_Start(dds->htimOffset, TIM_CHANNEL_3);
	// update the running flag
	dds->running = 1;
}

/**************************************
 * Stop the current DDS waveform
 * generation
 **************************************/
void DDS_Stop(DDS *dds) {
	// abort the dma transfer
	HAL_DMA_Abort(dds->htim->hdma[TIM_DMA_ID_UPDATE]);
	// stop the timer
	HAL_TIM_Base_Stop(dds->htim);
	// stop the timer for PWM
	HAL_TIM_PWM_Stop(dds->htimOffset, TIM_CHANNEL_3);
	// update the running flag
	dds->running = 0;
}

/**************************************
 * Update the DDS waveform
 * This function should be called
 * after changing the frequency, amplitude
 * and/or waveform
 **************************************/
void DDS_Update(DDS *dds) {
	uint8_t wasRunning = dds->running;
	// stop the current DDS waveform generation
	if(wasRunning) {
		DDS_Stop(dds);
	}

	/*********************************
	 * modify the wavetable, based on
	 * frequency and amplitude
	 *
	 * - for frequencies in range 1 Hz - 1 kHz,
	 *   the wavetable will have the maximum number
	 *   of samples (i.e. 256)
	 * - for frequencies in range 1.001 kHz - 5 kHz,
	 *   the wavetable will have half of the
	 *   maximum number of samples (i.e. 128)
	 * - for frequencies in range 5.001 kHz - 10 kHz,
	 *   the wavetable will have quarter of the maximum
	 *   number of samples (i.e. 64)
	 * - for frequencies in range 10.001 kHz - 100 kHz,
	 *   the wavetable will have one eighth of the
	 *   maximum number of samples (i.e. 32)
	 *
	 *   This bounds may be chosen by noting
	 *   the ARR values, nut for now this will do
	 */
	uint8_t k = 1;

	if(dds->freq <= 1000) {
		dds->wavetableSize = dds->unmodifiedWavetableSize;
		k = 1;
	} else if(dds->freq <= 5000) {
		dds->wavetableSize = dds->unmodifiedWavetableSize / 2;
		k = 2;
	} else if(dds->freq <= 10000) {
		dds->wavetableSize = dds->unmodifiedWavetableSize / 4;
		k = 4;
	} else if(dds->freq <= 100000) {
		dds->wavetableSize = dds->unmodifiedWavetableSize / 8;
		k = 8;
	}
	for(uint16_t i = 0; i < dds->wavetableSize; i++) {
		dds->wavetable[i] = (uint8_t)(((uint16_t)dds->unmodifiedWavetable[k*i]*dds->amp)/DDS_MAX_AMP);
	}

	/*********************************************
	 * Setup the timer auto reload register
	 * to achieve the specified waveform frequency.
	 * ARR value is determined using the fact that
	 * the DMA should transfer all wavetable samples
	 * with the specified frequency.
	 *
	 * NOTE: other configurations for the timer must
	 * be done previously (e.g. by using CubeMX):
	 * - Set PSC for 10 MHz timer clock frequency
	 *********************************************/
	__HAL_TIM_SET_AUTORELOAD(dds->htim, ((uint32_t)DDS_TIM_FREQ)/(dds->wavetableSize*dds->freq) - 1);

	/*********************************************
	 * NOTE: configurations for the DMA must
	 * be done previously (e.g. by using CubeMX)
	 * - Enable TIMx_UP request
	 * - Memory to peripheral transfer
	 * - Only increment memory address
	 * - Circular mode
	 *********************************************/

	// set the correct duty cycle value for PWM
	__HAL_TIM_SET_COMPARE(dds->htimOffset, TIM_CHANNEL_3, ((dds->amp*DDS_TIM_PWM_MAX_DC)/3300 - 1)/2);

	// start the new DDS waveform generation
	if(wasRunning) {
		DDS_Start(dds);
	}
}

/**************************************
 * Change DDS waveform frequency
 **************************************/
void DDS_ChangeFrequency(DDS *dds, uint32_t freq) {
	if(freq > DDS_MAX_FREQ) {
		dds->freq = DDS_MAX_FREQ;
	} else {
		dds->freq = freq;
	}
}

/**************************************
 * Change DDS waveform amplitude
 **************************************/
void DDS_ChangeAmplitude(DDS *dds, uint32_t amp) {
	if(amp < DDS_MIN_AMP) {
		dds->amp = DDS_MIN_AMP;
	} else if (amp > DDS_MAX_AMP){
		dds->amp = DDS_MAX_AMP;
	} else {
		dds->amp = amp;
	}
}

/**************************************
 * Change DDS waveform
 **************************************/
void DDS_ChangeWaveform(DDS *dds, const uint8_t *wavetable, uint16_t wavetableSize, WaveformType waveType) {
	dds->unmodifiedWavetable = wavetable;
	dds->unmodifiedWavetableSize = wavetableSize;
	dds->waveType = waveType;
}

/**************************************
 * Look-up tables (LUT) definitions
 **************************************/
const uint8_t SINEWAVE_LUT[SINEWAVE_LUT_SIZE] =
{
		0x80,0x83,0x86,0x89,0x8c,0x8f,0x92,0x95,0x98,0x9c,0x9f,0xa2,0xa5,0xa8,0xab,0xae,
		0xb0,0xb3,0xb6,0xb9,0xbc,0xbf,0xc1,0xc4,0xc7,0xc9,0xcc,0xce,0xd1,0xd3,0xd5,0xd8,
		0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xed,0xef,0xf0,0xf2,0xf3,0xf5,
		0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfc,0xfd,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xfe,0xfd,0xfc,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,
		0xf6,0xf5,0xf3,0xf2,0xf0,0xef,0xed,0xec,0xea,0xe8,0xe6,0xe4,0xe2,0xe0,0xde,0xdc,
		0xda,0xd8,0xd5,0xd3,0xd1,0xce,0xcc,0xc9,0xc7,0xc4,0xc1,0xbf,0xbc,0xb9,0xb6,0xb3,
		0xb0,0xae,0xab,0xa8,0xa5,0xa2,0x9f,0x9c,0x98,0x95,0x92,0x8f,0x8c,0x89,0x86,0x83,
		0x80,0x7c,0x79,0x76,0x73,0x70,0x6d,0x6a,0x67,0x63,0x60,0x5d,0x5a,0x57,0x54,0x51,
		0x4f,0x4c,0x49,0x46,0x43,0x40,0x3e,0x3b,0x38,0x36,0x33,0x31,0x2e,0x2c,0x2a,0x27,
		0x25,0x23,0x21,0x1f,0x1d,0x1b,0x19,0x17,0x15,0x13,0x12,0x10,0x0f,0x0d,0x0c,0x0a,
		0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x03,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x05,0x06,0x07,0x08,
		0x09,0x0a,0x0c,0x0d,0x0f,0x10,0x12,0x13,0x15,0x17,0x19,0x1b,0x1d,0x1f,0x21,0x23,
		0x25,0x27,0x2a,0x2c,0x2e,0x31,0x33,0x36,0x38,0x3b,0x3e,0x40,0x43,0x46,0x49,0x4c,
		0x4f,0x51,0x54,0x57,0x5a,0x5d,0x60,0x63,0x67,0x6a,0x6d,0x70,0x73,0x76,0x79,0x7c
};

const uint8_t SQUAREWAVE_LUT[SQUAREWAVE_LUT_SIZE] =
{
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
};

const uint8_t SAWTOOTHWAVE_LUT[SAWTOOTHWAVE_LUT_SIZE] =
{
		0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
		0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
		0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
		0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
		0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
		0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
		0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
		0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
		0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
		0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
		0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
		0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
		0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
		0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
		0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
		0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
};

const uint8_t TRIANGLEWAVE_LUT[TRIANGLEWAVE_LUT_SIZE] =
{
		0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
		0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
		0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
		0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
		0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
		0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
		0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
		0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
		0xff,0xfd,0xfb,0xf9,0xf7,0xf5,0xf3,0xf1,0xef,0xef,0xeb,0xe9,0xe7,0xe5,0xe3,0xe1,
		0xdf,0xdd,0xdb,0xd9,0xd7,0xd5,0xd3,0xd1,0xcf,0xcf,0xcb,0xc9,0xc7,0xc5,0xc3,0xc1,
		0xbf,0xbd,0xbb,0xb9,0xb7,0xb5,0xb3,0xb1,0xaf,0xaf,0xab,0xa9,0xa7,0xa5,0xa3,0xa1,
		0x9f,0x9d,0x9b,0x99,0x97,0x95,0x93,0x91,0x8f,0x8f,0x8b,0x89,0x87,0x85,0x83,0x81,
		0x7f,0x7d,0x7b,0x79,0x77,0x75,0x73,0x71,0x6f,0x6f,0x6b,0x69,0x67,0x65,0x63,0x61,
		0x5f,0x5d,0x5b,0x59,0x57,0x55,0x53,0x51,0x4f,0x4f,0x4b,0x49,0x47,0x45,0x43,0x41,
		0x3f,0x3d,0x3b,0x39,0x37,0x35,0x33,0x31,0x2f,0x2f,0x2b,0x29,0x27,0x25,0x23,0x21,
		0x1f,0x1d,0x1b,0x19,0x17,0x15,0x13,0x11,0x0f,0x0f,0x0b,0x09,0x07,0x05,0x03,0x01
};
